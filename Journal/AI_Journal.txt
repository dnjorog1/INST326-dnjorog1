Week 2:
I checked with AI on how to format the f-string in Ex. 1 and to make sure I was using .strip() 
correctly in Ex. 5. The rest I did on my own

I asked AI to confirm using max() for the late fee so it wouldn’t go negative (Ex. 6). 
Also needed help lining up the f-string formatting in Ex. 10.

I used AI once here just to make sure I was printing the type correctly in Ex. 16. 
I mixed up the comparison operators at first in Ex. 20, so I asked AI just to remind me the 
right way to write the boolean check

For Ex. 23, I already knew about .find(), but I wanted to confirm that checking != -1 is the right way 
to test if a word is there. In Ex. 25, I just asked AI to make sure combining both comparisons on one line 
was the cleanest way to do it.

Most of this part felt fine, but I asked AI to confirm the f-string syntax for rounding to two decimals in Ex. 27. 
For Ex. 30, I just double-checked if using the names none, single, and many for the booleans made sense. 



Week 3/ week 2 excercise:
#10 Safe remove if present
I checked with AI after hitting a ValueError. I mixed up remove() (by value) and pop() (by index). The fix was to 
guard the call: if "Quantum Design" in titles: titles.remove("Quantum Design").

#22 – Parse call number prefix
I asked an AI how to get characters before the first digit in a string. I wasn’t sure how to stop exactly when 
digits start and ignore the dot. The suggestion was to iterate over chars, break on the first digit, then keep only the leading letters.

#26 – Merge two shelves
I asked an AI how to merge two lists by alternating and then append the rest. I was stuck on stopping at the shorter list without an 
IndexError and how to add the leftovers. The tip was one while for the alternating part, then two small while loops to finish each list.

#28 – Find index of max without max()
I used AI because I kept forgetting to track both the max value and its index. The guidance was to set max_index = 0 and max_count = loan_counts[0], 
loop from 1, and update both when I see a bigger number.

#30 – Menu loop with input()
I used AI to figure out why my loop wasn’t behaving. I was comparing choice to numbers (1, 2, 3) instead of strings (“1”, “2”, “3”). I also needed a 
simple pattern for handling invalid choices without breaking the loop.

Week 4/ week 3 excercise:

I noticed I leaned on AI more once the exercises started chaining together or when I wasn’t sure about edge cases. For example:

Exercise 3 (fuzzy book search)- I asked AI to help me make the comparison case-insensitive and ignore extra spaces. I probably 
could have figured it out eventually, but it saved me time and I was a little stuck.

Exercise 5 (checkout_book) and Exercise 6 (return_book)-  I used AI to confirm my if/else logic and to check that I was updating 
the is_checked_out list correctly without breaking it.

Exercise 12 (search_titles_contains)-  I wasn’t sure about the case_sensitive part, so I used AI to get a simple example of how to structure it.

Exercise 19 (swap_books)-  This one was trickier since I had to swap values across three lists at once. I asked AI how to do this 
neatly without messing up the lists.

Exercise 30 (catalog_summary)-  I already had the idea, but I asked AI how to make the output format look clean and was 
reminded about using "\n".join() for multiple lines.

Week 4 excercise: 

For this week’s assignment, I used AI as a way to guide me through some of the trickier exercises. 
it was a great help when I wasn’t sure how to implement certain parts.

Exercise 6 (PatronID): I struggled with formatting the ID number so that it always showed six digits. I didn’t remember the exact syntax for padding 
numbers in Python f-strings. AI showed me the :06d format, which was really useful. 

Exercise 9 (GenreTagger): Working with sets inside a class was new for me. I wasn’t totally sure how to add and remove tags safely or check if a tag existed. 
AI helped me remember to use .add() and .remove().   

Exercise 10 (Rating): The average score calculation gave me issues at first. I could sum up the scores, but I didn’t know how to handle the case where the list was empty.
AI reminded me to check if len(self.scores) == 0: and return None before doing the math. That made my solution work correctly.

Exercise 19 (TopicCounter): Sorting the dictionary by values to find the top n topics was confusing. I didn’t know how to use sorted() with a lambda function on the 
dictionary’s items. AI showed me that pattern, and once I saw it, it clicked.


Week 5 Exercises:

For this week’s coding work, I used AI to help me understand some of the trickier parts of encapsulation and property setters. It was really useful for learning how to apply 
validation and private attributes the right way.

Exercise 3 (PagedBook): I wasn’t sure how to make sure the number of pages couldn’t be zero or negative. AI reminded me to coerce the input to an integer and then check if it 
was at least 1 before storing it.

Exercise 6 (FeeSchedule): The part where I had to accept numbers or numeric strings like "0.25" confused me at first. AI showed me that I could safely convert the value with float() 
and then check if it’s non-negative.

Exercise 11 (SimpleLoan): Comparing the due date to today’s date as strings was strange because I’m used to seeing people use datetime modules. AI helped me see that since both are 
in "YYYY-MM-DD" format, a normal string comparison works fine.

Exercise 17 (Account): Keeping the balance from ever going negative was tricky. I knew I needed to update it through the setter but didn’t know how to block withdrawals that would 
cause a negative amount. AI walked me through checking if self.balance - amt < 0: before subtracting it.

Exercise 20 (Settings): Managing multiple boolean flags in one private dictionary was new to me. I didn’t know how to make each flag have its own property while still updating the same dict. 
AI helped me figure out that I could use bool(value) in each setter to keep things simple and safe.



Week 6 Exercises:

I used AI a few times this week mostly to confirm that my logic and method types were right for the class design exercises. Things started getting a little more detailed with class, static, 
and instance methods all mixed together, so it helped me make sure I wasn’t mixing them up.

Exercise 3 (IdGenerator):
I wasn’t sure how to properly use a class attribute that keeps track of the counter for every new ID. I asked AI if it made sense to use @classmethod instead of @staticmethod since I needed to 
access and update the shared _counter. It confirmed that cls._counter was the right approach and helped me format the method neatly.

Exercise 10 (Library):
This one was harder because it connected several other classes like Catalog, Member, and Loan. I used AI to help me figure out how to combine them and use IdGenerator.next_id() when registering 
a new member. I also wanted to make sure I was creating the Loan with today’s date and calculating the due_date correctly, so AI reminded me how to use timedelta(days=policy.loan_days) to add days safely.

Exercise 15 (CirculationStats):
I got stuck trying to find the average loan length using the checkout_date and due_date. I wasn’t sure how to loop through each Loan object and calculate the total number of days. AI showed me a simple 
way to use my DateUtils.parse_ymd() helper and then subtract two date objects to get the difference in days. After that, dividing by len(loans) felt easy.

Exercise 19 (Acquisition):
I wanted to confirm the cleanest way to calculate discounts using a static method. At first, I tried doing it inside the instance method directly, but AI explained how I could call the static method 
from inside the class, like Acquisition.apply_discount(self.price, pct). It also reminded me to round the result to two decimals with round(..., 2) so the price would look neat.

Week 7 Journal

Exercise 3:
I asked AI to explain how to raise my own exception instead of just returning True or False. I wasn’t sure how to properly make a custom OverdueLoanError and then catch it in another function. 
The example it gave made it much easier to understand when to use try/except.

Exercise 5:
For the late-fee calculation, I wasn’t sure if checking for zero before dividing was the right way or if I should use a try/except. AI reminded me that it’s fine to raise a ZeroDivisionError 
myself and then show a friendly message in the example.

Exercise 6:
I needed help remembering how to close a file using try/finally. I usually use with open(), but this time we had to practice finally. AI helped me structure it so the file still 
closes even if an error happens.

Exercise 10:
I double-checked with AI about validating a member ID. I knew to strip spaces and make it uppercase, but I forgot how to check if it only contained letters and numbers. AI reminded
 me to use .isalnum() and that made the code cleaner.

Exercise 12:
I used AI to confirm the setup for a simple unittest. I wasn’t completely sure how to write the assertRaises part for invalid ISBNs, so I asked for a quick example. Seeing the 
structure made the test easier to write and helped me understand how unit tests report success.

Week 8 Journal

Exercise 3 (AudioBook with super()):
I asked AI for help on how to properly use super() when overriding the describe() method. I wasn’t sure how to include the base class’s description first and then add my own details for duration. 
AI reminded me that I could save the parent’s text in a variable like base_info = super().describe() and then just add my own text after it. That helped me understand how super() keeps the code cleaner.

Exercise 4 (ReferenceBook):
For this one, I used AI to confirm how to block reference books from being checked out. I understood the idea of returning 0 for the loan period, but I wasn’t sure how to connect that to the LoanDesk.checkout() method. 
AI showed me how to add a simple guard that raises LibraryError("non-circulating") when loan_period_days() is 0. It made sense after I saw the example.

Exercise 9 (Notifier and Composition):
This part was a little confusing at first because I mixed up inheritance with composition. I asked AI how to make LoanDesk use a Notifier without making it a subclass. It explained that I just need to give LoanDesk 
a notifier attribute and call self.notifier.notify() when a checkout happens. That made me realize composition basically means one class has another, not is another.

Exercise 20 (Polymorphic Fee Demo):
I wanted to make sure my end-to-end demo worked right, so I asked AI to double-check if my loop was calling the right method. I wasn’t sure if I needed if statements to tell the book types apart, but AI reminded me that 
polymorphism already handles that. So, I just used compute_fee(book, days_late) and it worked for all book types automatically. Seeing the different fees print out made it click how powerful polymorphism really is.