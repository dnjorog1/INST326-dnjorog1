Week 2:
I checked with AI on how to format the f-string in Ex. 1 and to make sure I was using .strip() 
correctly in Ex. 5. The rest I did on my own

I asked AI to confirm using max() for the late fee so it wouldn’t go negative (Ex. 6). 
Also needed help lining up the f-string formatting in Ex. 10.

I used AI once here just to make sure I was printing the type correctly in Ex. 16. 
I mixed up the comparison operators at first in Ex. 20, so I asked AI just to remind me the 
right way to write the boolean check

For Ex. 23, I already knew about .find(), but I wanted to confirm that checking != -1 is the right way 
to test if a word is there. In Ex. 25, I just asked AI to make sure combining both comparisons on one line 
was the cleanest way to do it.

Most of this part felt fine, but I asked AI to confirm the f-string syntax for rounding to two decimals in Ex. 27. 
For Ex. 30, I just double-checked if using the names none, single, and many for the booleans made sense. 



Week 3/ week 2 excercise:
#10 Safe remove if present
I checked with AI after hitting a ValueError. I mixed up remove() (by value) and pop() (by index). The fix was to 
guard the call: if "Quantum Design" in titles: titles.remove("Quantum Design").

#22 – Parse call number prefix
I asked an AI how to get characters before the first digit in a string. I wasn’t sure how to stop exactly when 
digits start and ignore the dot. The suggestion was to iterate over chars, break on the first digit, then keep only the leading letters.

#26 – Merge two shelves
I asked an AI how to merge two lists by alternating and then append the rest. I was stuck on stopping at the shorter list without an 
IndexError and how to add the leftovers. The tip was one while for the alternating part, then two small while loops to finish each list.

#28 – Find index of max without max()
I used AI because I kept forgetting to track both the max value and its index. The guidance was to set max_index = 0 and max_count = loan_counts[0], 
loop from 1, and update both when I see a bigger number.

#30 – Menu loop with input()
I used AI to figure out why my loop wasn’t behaving. I was comparing choice to numbers (1, 2, 3) instead of strings (“1”, “2”, “3”). I also needed a 
simple pattern for handling invalid choices without breaking the loop.

Week 4/ week 3 excercise:

I noticed I leaned on AI more once the exercises started chaining together or when I wasn’t sure about edge cases. For example:

Exercise 3 (fuzzy book search)- I asked AI to help me make the comparison case-insensitive and ignore extra spaces. I probably 
could have figured it out eventually, but it saved me time and I was a little stuck.

Exercise 5 (checkout_book) and Exercise 6 (return_book)-  I used AI to confirm my if/else logic and to check that I was updating 
the is_checked_out list correctly without breaking it.

Exercise 12 (search_titles_contains)-  I wasn’t sure about the case_sensitive part, so I used AI to get a simple example of how to structure it.

Exercise 19 (swap_books)-  This one was trickier since I had to swap values across three lists at once. I asked AI how to do this 
neatly without messing up the lists.

Exercise 30 (catalog_summary)-  I already had the idea, but I asked AI how to make the output format look clean and was 
reminded about using "\n".join() for multiple lines.

Week 4 excercise: 

For this week’s assignment, I used AI as a way to guide me through some of the trickier exercises. 
it was a great help when I wasn’t sure how to implement certain parts.

Exercise 6 (PatronID): I struggled with formatting the ID number so that it always showed six digits. I didn’t remember the exact syntax for padding 
numbers in Python f-strings. AI showed me the :06d format, which was really useful. 

Exercise 9 (GenreTagger): Working with sets inside a class was new for me. I wasn’t totally sure how to add and remove tags safely or check if a tag existed. 
AI helped me remember to use .add() and .remove().   

Exercise 10 (Rating): The average score calculation gave me issues at first. I could sum up the scores, but I didn’t know how to handle the case where the list was empty.
AI reminded me to check if len(self.scores) == 0: and return None before doing the math. That made my solution work correctly.

Exercise 19 (TopicCounter): Sorting the dictionary by values to find the top n topics was confusing. I didn’t know how to use sorted() with a lambda function on the 
dictionary’s items. AI showed me that pattern, and once I saw it, it clicked.


Week 5 Exercises:

For this week’s coding work, I used AI to help me understand some of the trickier parts of encapsulation and property setters. It was really useful for learning how to apply 
validation and private attributes the right way.

Exercise 3 (PagedBook): I wasn’t sure how to make sure the number of pages couldn’t be zero or negative. AI reminded me to coerce the input to an integer and then check if it 
was at least 1 before storing it.

Exercise 6 (FeeSchedule): The part where I had to accept numbers or numeric strings like "0.25" confused me at first. AI showed me that I could safely convert the value with float() 
and then check if it’s non-negative.

Exercise 11 (SimpleLoan): Comparing the due date to today’s date as strings was strange because I’m used to seeing people use datetime modules. AI helped me see that since both are 
in "YYYY-MM-DD" format, a normal string comparison works fine.

Exercise 17 (Account): Keeping the balance from ever going negative was tricky. I knew I needed to update it through the setter but didn’t know how to block withdrawals that would 
cause a negative amount. AI walked me through checking if self.balance - amt < 0: before subtracting it.

Exercise 20 (Settings): Managing multiple boolean flags in one private dictionary was new to me. I didn’t know how to make each flag have its own property while still updating the same dict. 
AI helped me figure out that I could use bool(value) in each setter to keep things simple and safe.



Week 6 Exercises:

I used AI a few times this week mostly to confirm that my logic and method types were right for the class design exercises. Things started getting a little more detailed with class, static, 
and instance methods all mixed together, so it helped me make sure I wasn’t mixing them up.

Exercise 3 (IdGenerator):
I wasn’t sure how to properly use a class attribute that keeps track of the counter for every new ID. I asked AI if it made sense to use @classmethod instead of @staticmethod since I needed to 
access and update the shared _counter. It confirmed that cls._counter was the right approach and helped me format the method neatly.

Exercise 10 (Library):
This one was harder because it connected several other classes like Catalog, Member, and Loan. I used AI to help me figure out how to combine them and use IdGenerator.next_id() when registering 
a new member. I also wanted to make sure I was creating the Loan with today’s date and calculating the due_date correctly, so AI reminded me how to use timedelta(days=policy.loan_days) to add days safely.

Exercise 15 (CirculationStats):
I got stuck trying to find the average loan length using the checkout_date and due_date. I wasn’t sure how to loop through each Loan object and calculate the total number of days. AI showed me a simple 
way to use my DateUtils.parse_ymd() helper and then subtract two date objects to get the difference in days. After that, dividing by len(loans) felt easy.

Exercise 19 (Acquisition):
I wanted to confirm the cleanest way to calculate discounts using a static method. At first, I tried doing it inside the instance method directly, but AI explained how I could call the static method 
from inside the class, like Acquisition.apply_discount(self.price, pct). It also reminded me to round the result to two decimals with round(..., 2) so the price would look neat.

Week 7 Journal

Exercise 3:
I asked AI to explain how to raise my own exception instead of just returning True or False. I wasn’t sure how to properly make a custom OverdueLoanError and then catch it in another function. 
The example it gave made it much easier to understand when to use try/except.

Exercise 5:
For the late-fee calculation, I wasn’t sure if checking for zero before dividing was the right way or if I should use a try/except. AI reminded me that it’s fine to raise a ZeroDivisionError 
myself and then show a friendly message in the example.

Exercise 6:
I needed help remembering how to close a file using try/finally. I usually use with open(), but this time we had to practice finally. AI helped me structure it so the file still 
closes even if an error happens.

Exercise 10:
I double-checked with AI about validating a member ID. I knew to strip spaces and make it uppercase, but I forgot how to check if it only contained letters and numbers. AI reminded
 me to use .isalnum() and that made the code cleaner.

Exercise 12:
I used AI to confirm the setup for a simple unittest. I wasn’t completely sure how to write the assertRaises part for invalid ISBNs, so I asked for a quick example. Seeing the 
structure made the test easier to write and helped me understand how unit tests report success.

Week 8 Journal

Exercise 3 (AudioBook with super()):
I asked AI for help on how to properly use super() when overriding the describe() method. I wasn’t sure how to include the base class’s description first and then add my own details for duration. 
AI reminded me that I could save the parent’s text in a variable like base_info = super().describe() and then just add my own text after it. That helped me understand how super() keeps the code cleaner.

Exercise 4 (ReferenceBook):
For this one, I used AI to confirm how to block reference books from being checked out. I understood the idea of returning 0 for the loan period, but I wasn’t sure how to connect that to the LoanDesk.checkout() method. 
AI showed me how to add a simple guard that raises LibraryError("non-circulating") when loan_period_days() is 0. It made sense after I saw the example.

Exercise 9 (Notifier and Composition):
This part was a little confusing at first because I mixed up inheritance with composition. I asked AI how to make LoanDesk use a Notifier without making it a subclass. It explained that I just need to give LoanDesk 
a notifier attribute and call self.notifier.notify() when a checkout happens. That made me realize composition basically means one class has another, not is another.

Exercise 20 (Polymorphic Fee Demo):
I wanted to make sure my end-to-end demo worked right, so I asked AI to double-check if my loop was calling the right method. I wasn’t sure if I needed if statements to tell the book types apart, but AI reminded me that 
polymorphism already handles that. So, I just used compute_fee(book, days_late) and it worked for all book types automatically. Seeing the different fees print out made it click how powerful polymorphism really is.

Week 9 Journal
Exercise 5 (Virtual Subclass Registration):
I asked AI for help because I did not fully understand how a “virtual subclass” works in Python. I knew I wasn’t supposed to inherit from LibraryItem, but I still had to make the class act like one. I was confused 
about which methods and properties I needed to include so that PDFPamphlet would pass isinstance(pdf, LibraryItem). AI helped me list out the parts that had to be there and reminded me to call LibraryItem.register(PDFPamphlet)
 at the end. Once I saw the pattern, it made a lot more sense.

Exercise 10 (Abstract daily_late_fee):
I used AI here because I kept forgetting where the abstract method was supposed to go and how the subclasses were supposed to override it. I understood the idea, but I wasn’t sure how to structure the method in the 
base class without causing errors. AI explained that the abstract method goes in LibraryItem and each subclass just returns its own fee number. The explanation was simple and helped me finish it without guessing.

Exercise 16 (Swap Implementation Behind the ABC):
I asked AI for help on this one mainly because of the PDFPamphlet class. When I tried checking it out with LoanDesk, I kept getting attribute errors about missing fields like isbn and borrowable. I wasn’t sure what I was missing. 
AI helped me fix the class so it actually behaved like a real LibraryItem, even though it wasn’t inheriting from it. After that, the checkout function worked fine.

Exercise 17 (full_label template method):
I needed help here because I first tried rewriting LibraryItem using the class LibraryItem(LibraryItem) pattern from earlier questions, but the subclasses still didn’t get the new method. I didn’t realize that this created a new 
subclass instead of updating the original one. AI explained that for this exercise, I had to attach the method directly to the existing LibraryItem using LibraryItem.full_label = full_label. After that, the subclasses started 
picking up the method, and everything worked the way the instructions said.


Week 10 AI Journal

For this week’s exercises, I used AI a few times mainly to help me understand some of the new data-model features like properties, @dataclass options, and special methods. A lot of the ideas were new to me, so I checked with AI 
whenever I wasn’t 100% sure about the pattern.

Exercise 1 (title property validation):
I already knew how to write a basic @property, but I wasn’t sure how to override the dataclass’s default behavior and replace the title field with a private _title. I asked AI to show me how to re-route the assignment 
inside __post_init__ so the validation still runs. After seeing the pattern once, the whole idea made a lot more sense.

Exercise 3 (__post_init__ normalization):
I needed help remembering the cleanest way to strip hyphens and spaces from the ISBN and then uppercase the title. I also mixed up when __post_init__ actually gets called. AI explained that the dataclass creates the 
instance first, then runs __post_init__, so any cleanup done there will apply to the already-created object. That helped me avoid putting the cleanup in the wrong place.

Exercise 6 (__delitem__ on Catalog):
I thought that just deleting from the internal dictionary would automatically make del catalog["111"] work, but I kept getting a TypeError. AI pointed out that I needed to actually define __delitem__ instead of just using remove_book(). 
Once I added the method and raised the right KeyError, the deletion finally acted like a real container.

Exercise 15 (defensive copy with to_list):
I wasn’t sure what “defensive copying” meant in this context. I thought returning the actual internal dictionary values was fine, but AI reminded me that if I return the real list, someone could modify it and break the catalog. 
It helped me realize that returning list(sorted(self._books.values())) protects my internal structure, which is the whole point of the exercise.

Overall, I leaned on AI for the trickier parts involving Python’s data model and how containers behave, but I still wrote the code myself once I understood the patterns. This week definitely felt more “software-engineer-ish,” 
and having AI clarify the patterns saved me time when I got stuck.

Week 12 Ai Journal

This week I used AI to brain storm schools I would like to attend for my masters program and which was the best overall with cost, travel, and course strength. I also used Ai to help me create a study guide for my math final coming up,
it helped create a study plan for not just the math class but for my other classes as well and my projects.